module mlp_module (
    input clk,  // clock
    input rst,  // reset
    input in [28][28][1],
    output out[4]
) {
    enum STATE{LAYER1,}
    .clk(clk){
        dff state
        #SIZE(784){
        looping_carry_save adder1 [16] 
            }
         #SIZE(16){
        looping_carry_save adder2 [10] 
            }
        #SIZE(10){
        looping_carry_save adder3 [10] 
            }
        #INPUT_SIZE(784){
           input_neuron input_layer[16] 
        }
        #INPUT_SIZE(16){
           hidden_neuron hidden_layer[10] 
        }
        #INPUT_SIZE(10){
           output_neuron output_layer[10] 
        }
        choose pooling(.rst(rst))
        
    }
    weights weights
    layer2 w2
    layer3 w3
    relu relu[16] 
    relu relu2[10] 
    sigmoid sigmoid[10]
    always {
        input_layer.in = 16x{{$flatten(in)}}
        adder1.array = input_layer.out
        adder1.start =1
        input_layer.weights = weights.out1
        adder1.bias = weights.out2
        relu.value  =adder1.out
        
        hidden_layer.in = 10x{{relu.out}}
        adder2.array = hidden_layer.out
        adder2.start = adder1.ready
        hidden_layer.weights = w2.w
        adder2.bias = w2.b
        relu2.value  = adder2.out
        
        
        output_layer.in = 10x{{relu2.out}}
        adder3.start = adder2.ready
        adder3.array = output_layer.out
        output_layer.weights = w3.w
        adder3.bias = w3.b
        sigmoid.x = adder3.out
        
        pooling.in = sigmoid.out
        out = pooling.out
        
    }
}