/*
    This file was generated automatically by Alchitry Labs 2.0.34-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module mlp_module (
        input wire clk,
        input wire rst,
        input wire [27:0][27:0][0:0] in,
        output reg [3:0] out,
        output reg [15:0][15:0] relu1_,
        output reg [15:0][15:0] adder1_,
        output reg [9:0][31:0] sigmoid2_,
        output reg [9:0][31:0] adder2_
    );
    localparam _MP_SIZE_1254426041 = 10'h310;
    localparam _MP_INTEGER_SIZE_1254426041 = 5'h10;
    logic signed [15:0][783:0][15:0] M_adder1_array;
    logic signed [15:0][15:0] M_adder1_out;
    logic signed [15:0][15:0] M_adder1_bias;
    logic [15:0][15:0] M_adder1_in;
    logic [15:0] M_adder1_start;
    logic [15:0] M_adder1_ready;
    
    genvar idx_0_1254426041;
    
    generate
        for (idx_0_1254426041 = 0; idx_0_1254426041 < 16; idx_0_1254426041 = idx_0_1254426041 + 1) begin: forLoop_idx_0_1254426041
            looping_carry_save #(
                .SIZE(_MP_SIZE_1254426041),
                .INTEGER_SIZE(_MP_INTEGER_SIZE_1254426041)
            ) adder1 (
                .clk(clk),
                .array(M_adder1_array[idx_0_1254426041]),
                .out(M_adder1_out[idx_0_1254426041]),
                .bias(M_adder1_bias[idx_0_1254426041]),
                .in(M_adder1_in[idx_0_1254426041]),
                .start(M_adder1_start[idx_0_1254426041]),
                .ready(M_adder1_ready[idx_0_1254426041])
            );
        end
    endgenerate
    
    
    localparam _MP_SIZE_1223020928 = 5'h10;
    localparam _MP_INTEGER_SIZE_1223020928 = 6'h20;
    logic signed [9:0][15:0][31:0] M_adder3_array;
    logic signed [9:0][31:0] M_adder3_out;
    logic signed [9:0][31:0] M_adder3_bias;
    logic [9:0][31:0] M_adder3_in;
    logic [9:0] M_adder3_start;
    logic [9:0] M_adder3_ready;
    
    genvar idx_0_1223020928;
    
    generate
        for (idx_0_1223020928 = 0; idx_0_1223020928 < 10; idx_0_1223020928 = idx_0_1223020928 + 1) begin: forLoop_idx_0_1223020928
            looping_carry_save #(
                .SIZE(_MP_SIZE_1223020928),
                .INTEGER_SIZE(_MP_INTEGER_SIZE_1223020928)
            ) adder3 (
                .clk(clk),
                .array(M_adder3_array[idx_0_1223020928]),
                .out(M_adder3_out[idx_0_1223020928]),
                .bias(M_adder3_bias[idx_0_1223020928]),
                .in(M_adder3_in[idx_0_1223020928]),
                .start(M_adder3_start[idx_0_1223020928]),
                .ready(M_adder3_ready[idx_0_1223020928])
            );
        end
    endgenerate
    
    
    localparam _MP_INPUT_SIZE_1871527480 = 10'h310;
    logic [15:0][783:0] M_input_layer_in;
    logic [15:0][783:0][15:0] M_input_layer_weights;
    logic [15:0][783:0][15:0] M_input_layer_out;
    
    genvar idx_0_1871527480;
    
    generate
        for (idx_0_1871527480 = 0; idx_0_1871527480 < 16; idx_0_1871527480 = idx_0_1871527480 + 1) begin: forLoop_idx_0_1871527480
            input_neuron #(
                .INPUT_SIZE(_MP_INPUT_SIZE_1871527480)
            ) input_layer (
                .clk(clk),
                .in(M_input_layer_in[idx_0_1871527480]),
                .weights(M_input_layer_weights[idx_0_1871527480]),
                .out(M_input_layer_out[idx_0_1871527480])
            );
        end
    endgenerate
    
    
    localparam _MP_INPUT_SIZE_410701040 = 5'h10;
    logic signed [9:0][15:0][15:0] M_output_layer_in;
    logic signed [9:0][15:0][15:0] M_output_layer_weights;
    logic [9:0][15:0][31:0] M_output_layer_out;
    
    genvar idx_0_410701040;
    
    generate
        for (idx_0_410701040 = 0; idx_0_410701040 < 10; idx_0_410701040 = idx_0_410701040 + 1) begin: forLoop_idx_0_410701040
            output_neuron #(
                .INPUT_SIZE(_MP_INPUT_SIZE_410701040)
            ) output_layer (
                .clk(clk),
                .in(M_output_layer_in[idx_0_410701040]),
                .weights(M_output_layer_weights[idx_0_410701040]),
                .out(M_output_layer_out[idx_0_410701040])
            );
        end
    endgenerate
    
    
    logic signed [9:0][31:0] M_pooling_in;
    logic [3:0] M_pooling_out;
    
    choose pooling (
        .rst(rst),
        .clk(clk),
        .in(M_pooling_in),
        .out(M_pooling_out)
    );
    
    
    logic [3:0] D_state_d, D_state_q = 0;
    localparam E_States_DEFAULT = 2'h0;
    localparam E_States_LAYER1 = 2'h1;
    localparam E_States_LAYER2 = 2'h2;
    localparam E_States_LAYER3 = 2'h3;
    logic [15:0][783:0][15:0] M_weights_out1;
    logic [15:0][15:0] M_weights_out2;
    
    weights weights (
        .out1(M_weights_out1),
        .out2(M_weights_out2)
    );
    
    
    logic [9:0][15:0][15:0] M_w3_w;
    logic [9:0][31:0] M_w3_b;
    
    layer3 w3 (
        .w(M_w3_w),
        .b(M_w3_b)
    );
    
    
    localparam _MP_LENGTH_2060147532 = 5'h10;
    logic [15:0][15:0] M_relu_value;
    logic [15:0][15:0] M_relu_out;
    
    genvar idx_0_2060147532;
    
    generate
        for (idx_0_2060147532 = 0; idx_0_2060147532 < 16; idx_0_2060147532 = idx_0_2060147532 + 1) begin: forLoop_idx_0_2060147532
            relu #(
                .LENGTH(_MP_LENGTH_2060147532)
            ) relu (
                .value(M_relu_value[idx_0_2060147532]),
                .out(M_relu_out[idx_0_2060147532])
            );
        end
    endgenerate
    
    
    logic [9:0][31:0] M_sigmoid_x;
    logic [9:0][31:0] M_sigmoid_out;
    
    genvar idx_0_387057133;
    
    generate
        for (idx_0_387057133 = 0; idx_0_387057133 < 10; idx_0_387057133 = idx_0_387057133 + 1) begin: forLoop_idx_0_387057133
            sigmoid sigmoid (
                .x(M_sigmoid_x[idx_0_387057133]),
                .out(M_sigmoid_out[idx_0_387057133])
            );
        end
    endgenerate
    
    
    always @* begin
        D_state_d = D_state_q;
        
        M_input_layer_in = {5'h10{{in}}};
        M_adder1_array = M_input_layer_out;
        M_input_layer_weights = M_weights_out1;
        M_adder1_bias = M_weights_out2;
        M_relu_value = $signed(M_adder1_out);
        M_output_layer_in = {4'ha{{M_relu_out}}};
        M_adder3_array = M_output_layer_out;
        M_output_layer_weights = M_w3_w;
        M_adder3_bias = M_w3_b;
        M_sigmoid_x = $signed(M_adder3_out);
        M_pooling_in = M_sigmoid_out;
        M_adder1_start = 16'h0;
        adder1_ = $signed(M_adder1_out);
        adder2_ = $signed(M_adder3_out);
        relu1_ = M_relu_out;
        sigmoid2_ = M_sigmoid_out;
        M_adder3_start = 10'h0;
        out = M_pooling_out;
        
        case (D_state_q)
            2'h0: begin
                M_adder1_start = 16'h0;
                D_state_d = 2'h1;
            end
            2'h1: begin
                M_adder1_start = 16'hffff;
                if ((&M_adder1_ready)) begin
                    D_state_d = 2'h3;
                end
            end
            2'h3: begin
                M_adder3_start = 10'h3ff;
                if ((&M_adder3_ready)) begin
                    D_state_d = 2'h3;
                end
            end
        endcase
    end
    
    
    always @(posedge (clk)) begin
        D_state_q <= D_state_d;
        
    end
endmodule