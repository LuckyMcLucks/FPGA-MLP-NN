/*
    This file was generated automatically by Alchitry Labs 2.0.34-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module mlp_module (
        input wire clk,
        input wire rst,
        input wire [27:0][27:0] in,
        output reg [3:0] out
    );
    localparam _MP_INPUT_SIZE_2009982348 = 10'h310;
    logic [15:0][783:0] M_input_layer_in;
    logic [15:0][783:0][7:0] M_input_layer_weights;
    logic [15:0][7:0] M_input_layer_bias;
    logic [15:0][7:0] M_input_layer_out;
    
    genvar idx_0_2009982348;
    
    generate
        for (idx_0_2009982348 = 0; idx_0_2009982348 < 16; idx_0_2009982348 = idx_0_2009982348 + 1) begin: forLoop_idx_0_2009982348
            input_neuron #(
                .INPUT_SIZE(_MP_INPUT_SIZE_2009982348)
            ) input_layer (
                .clk(clk),
                .in(M_input_layer_in[idx_0_2009982348]),
                .weights(M_input_layer_weights[idx_0_2009982348]),
                .bias(M_input_layer_bias[idx_0_2009982348]),
                .out(M_input_layer_out[idx_0_2009982348])
            );
        end
    endgenerate
    
    
    localparam _MP_INPUT_SIZE_1996756110 = 5'h10;
    logic [9:0][15:0][7:0] M_hidden_layer_in;
    logic [9:0][15:0][7:0] M_hidden_layer_weights;
    logic [9:0][7:0] M_hidden_layer_bias;
    logic [9:0][7:0] M_hidden_layer_out;
    
    genvar idx_0_1996756110;
    
    generate
        for (idx_0_1996756110 = 0; idx_0_1996756110 < 10; idx_0_1996756110 = idx_0_1996756110 + 1) begin: forLoop_idx_0_1996756110
            hidden_neuron #(
                .INPUT_SIZE(_MP_INPUT_SIZE_1996756110)
            ) hidden_layer (
                .clk(clk),
                .in(M_hidden_layer_in[idx_0_1996756110]),
                .weights(M_hidden_layer_weights[idx_0_1996756110]),
                .bias(M_hidden_layer_bias[idx_0_1996756110]),
                .out(M_hidden_layer_out[idx_0_1996756110])
            );
        end
    endgenerate
    
    
    localparam _MP_INPUT_SIZE_1105080993 = 4'ha;
    logic [9:0][9:0][7:0] M_output_layer_in;
    logic [9:0][9:0][7:0] M_output_layer_weights;
    logic [9:0][7:0] M_output_layer_bias;
    logic [9:0][7:0] M_output_layer_out;
    
    genvar idx_0_1105080993;
    
    generate
        for (idx_0_1105080993 = 0; idx_0_1105080993 < 10; idx_0_1105080993 = idx_0_1105080993 + 1) begin: forLoop_idx_0_1105080993
            output_neuron #(
                .INPUT_SIZE(_MP_INPUT_SIZE_1105080993)
            ) output_layer (
                .clk(clk),
                .in(M_output_layer_in[idx_0_1105080993]),
                .weights(M_output_layer_weights[idx_0_1105080993]),
                .bias(M_output_layer_bias[idx_0_1105080993]),
                .out(M_output_layer_out[idx_0_1105080993])
            );
        end
    endgenerate
    
    
    logic [9:0][7:0] M_pooling_in;
    logic [3:0] M_pooling_out;
    
    choose pooling (
        .rst(rst),
        .clk(clk),
        .in(M_pooling_in),
        .out(M_pooling_out)
    );
    
    
    logic [15:0][783:0][7:0] M_weights_out1;
    logic [15:0][7:0] M_weights_out2;
    
    weights weights (
        .out1(M_weights_out1),
        .out2(M_weights_out2)
    );
    
    
    logic [9:0][15:0][7:0] M_w2_w;
    logic [9:0][7:0] M_w2_b;
    
    layer2 w2 (
        .w(M_w2_w),
        .b(M_w2_b)
    );
    
    
    logic [9:0][9:0][7:0] M_w3_w;
    logic [9:0][7:0] M_w3_b;
    
    layer3 w3 (
        .w(M_w3_w),
        .b(M_w3_b)
    );
    
    
    always @* begin
        M_input_layer_in = {5'h10{{in}}};
        M_input_layer_weights = M_weights_out1;
        M_input_layer_bias = M_weights_out2;
        M_hidden_layer_in = {4'ha{{M_input_layer_out}}};
        M_hidden_layer_weights = M_w2_w;
        M_hidden_layer_bias = M_w2_b;
        M_output_layer_in = {4'ha{{M_hidden_layer_out}}};
        M_output_layer_weights = M_w3_w;
        M_output_layer_bias = M_w3_b;
        M_pooling_in = M_output_layer_out;
        out = M_pooling_out;
    end
    
    
endmodule