/*
    This file was generated automatically by Alchitry Labs 2.0.34-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module mlp_module (
        input wire clk,
        input wire rst,
        input wire [27:0][27:0][0:0] in,
        output reg [15:0][15:0] relu1_,
        output reg [15:0][15:0] adder1_,
        output reg [15:0] out,
        output reg [9:0][31:0] adder3_
    );
    localparam _MP_SIZE_2043118135 = 10'h310;
    localparam _MP_INTEGER_SIZE_2043118135 = 5'h10;
    logic signed [15:0][783:0][15:0] M_adder1_array;
    logic signed [15:0][15:0] M_adder1_out;
    logic signed [15:0][15:0] M_adder1_bias;
    logic [15:0][15:0] M_adder1_in;
    logic [15:0] M_adder1_start;
    logic [15:0] M_adder1_ready;
    
    genvar idx_0_2043118135;
    
    generate
        for (idx_0_2043118135 = 0; idx_0_2043118135 < 16; idx_0_2043118135 = idx_0_2043118135 + 1) begin: forLoop_idx_0_2043118135
            looping_carry_save #(
                .SIZE(_MP_SIZE_2043118135),
                .INTEGER_SIZE(_MP_INTEGER_SIZE_2043118135)
            ) adder1 (
                .clk(clk),
                .array(M_adder1_array[idx_0_2043118135]),
                .out(M_adder1_out[idx_0_2043118135]),
                .bias(M_adder1_bias[idx_0_2043118135]),
                .in(M_adder1_in[idx_0_2043118135]),
                .start(M_adder1_start[idx_0_2043118135]),
                .ready(M_adder1_ready[idx_0_2043118135])
            );
        end
    endgenerate
    
    
    localparam _MP_SIZE_628266401 = 5'h10;
    localparam _MP_INTEGER_SIZE_628266401 = 6'h20;
    logic signed [9:0][15:0][31:0] M_adder3_array;
    logic signed [9:0][31:0] M_adder3_out;
    logic signed [9:0][31:0] M_adder3_bias;
    logic [9:0][31:0] M_adder3_in;
    logic [9:0] M_adder3_start;
    logic [9:0] M_adder3_ready;
    
    genvar idx_0_628266401;
    
    generate
        for (idx_0_628266401 = 0; idx_0_628266401 < 10; idx_0_628266401 = idx_0_628266401 + 1) begin: forLoop_idx_0_628266401
            looping_carry_save #(
                .SIZE(_MP_SIZE_628266401),
                .INTEGER_SIZE(_MP_INTEGER_SIZE_628266401)
            ) adder3 (
                .clk(clk),
                .array(M_adder3_array[idx_0_628266401]),
                .out(M_adder3_out[idx_0_628266401]),
                .bias(M_adder3_bias[idx_0_628266401]),
                .in(M_adder3_in[idx_0_628266401]),
                .start(M_adder3_start[idx_0_628266401]),
                .ready(M_adder3_ready[idx_0_628266401])
            );
        end
    endgenerate
    
    
    localparam _MP_INPUT_SIZE_1003378745 = 10'h310;
    logic [15:0][783:0] M_input_layer_in;
    logic [15:0][783:0][15:0] M_input_layer_weights;
    logic [15:0][783:0][15:0] M_input_layer_out;
    
    genvar idx_0_1003378745;
    
    generate
        for (idx_0_1003378745 = 0; idx_0_1003378745 < 16; idx_0_1003378745 = idx_0_1003378745 + 1) begin: forLoop_idx_0_1003378745
            input_neuron #(
                .INPUT_SIZE(_MP_INPUT_SIZE_1003378745)
            ) input_layer (
                .clk(clk),
                .in(M_input_layer_in[idx_0_1003378745]),
                .weights(M_input_layer_weights[idx_0_1003378745]),
                .out(M_input_layer_out[idx_0_1003378745])
            );
        end
    endgenerate
    
    
    localparam _MP_INPUT_SIZE_1063959539 = 5'h10;
    logic signed [9:0][15:0][15:0] M_output_layer_in;
    logic signed [9:0][15:0][15:0] M_output_layer_weights;
    logic [9:0][15:0][31:0] M_output_layer_out;
    
    genvar idx_0_1063959539;
    
    generate
        for (idx_0_1063959539 = 0; idx_0_1063959539 < 10; idx_0_1063959539 = idx_0_1063959539 + 1) begin: forLoop_idx_0_1063959539
            output_neuron #(
                .INPUT_SIZE(_MP_INPUT_SIZE_1063959539)
            ) output_layer (
                .clk(clk),
                .in(M_output_layer_in[idx_0_1063959539]),
                .weights(M_output_layer_weights[idx_0_1063959539]),
                .out(M_output_layer_out[idx_0_1063959539])
            );
        end
    endgenerate
    
    
    logic signed [9:0][31:0] M_pooling_in;
    logic [3:0] M_pooling_out;
    
    choose pooling (
        .rst(rst),
        .clk(clk),
        .in(M_pooling_in),
        .out(M_pooling_out)
    );
    
    
    localparam E_States_DEFAULT = 2'h0;
    localparam E_States_LAYER1 = 2'h1;
    localparam E_States_LAYER2 = 2'h2;
    localparam E_States_LAYER3 = 2'h3;
    logic [1:0] D_state_d, D_state_q = 2'h0;
    logic [15:0][783:0][15:0] M_weights_out1;
    logic [15:0][15:0] M_weights_out2;
    
    weights weights (
        .out1(M_weights_out1),
        .out2(M_weights_out2)
    );
    
    
    logic [9:0][15:0][15:0] M_w3_w;
    logic [9:0][31:0] M_w3_b;
    
    layer3 w3 (
        .w(M_w3_w),
        .b(M_w3_b)
    );
    
    
    localparam _MP_LENGTH_576714169 = 5'h10;
    logic [15:0][15:0] M_relu_value;
    logic [15:0][15:0] M_relu_out;
    
    genvar idx_0_576714169;
    
    generate
        for (idx_0_576714169 = 0; idx_0_576714169 < 16; idx_0_576714169 = idx_0_576714169 + 1) begin: forLoop_idx_0_576714169
            relu #(
                .LENGTH(_MP_LENGTH_576714169)
            ) relu (
                .value(M_relu_value[idx_0_576714169]),
                .out(M_relu_out[idx_0_576714169])
            );
        end
    endgenerate
    
    
    always @* begin
        D_state_d = D_state_q;
        
        M_input_layer_in = {5'h10{{in}}};
        M_adder1_array = M_input_layer_out;
        M_input_layer_weights = M_weights_out1;
        M_adder1_bias = M_weights_out2;
        M_relu_value = $signed(M_adder1_out);
        M_output_layer_in = {4'ha{{M_relu_out}}};
        M_adder3_array = M_output_layer_out;
        M_output_layer_weights = M_w3_w;
        M_adder3_bias = M_w3_b;
        M_pooling_in = $signed(M_adder3_out);
        relu1_ = M_relu_out;
        out = M_pooling_out;
        adder1_ = $signed(M_adder1_out);
        M_adder1_start = 16'h0;
        M_adder3_start = 10'h0;
        adder3_ = $signed(M_adder3_out);
        
        case (D_state_q)
            2'h0: begin
                M_adder1_start = 16'h0;
                D_state_d = 2'h1;
            end
            2'h1: begin
                M_adder1_start = 16'hffff;
                if ((&M_adder1_ready)) begin
                    D_state_d = 2'h3;
                end
            end
            2'h3: begin
                M_adder3_start = 10'h3ff;
                if ((&M_adder3_ready)) begin
                    D_state_d = 2'h3;
                end
            end
        endcase
    end
    
    
    always @(posedge (clk)) begin
        D_state_q <= D_state_d;
        
    end
endmodule